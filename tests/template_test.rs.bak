use cargo_forge::TemplateEngine;
use tera::Context;
use std::collections::HashMap;

#[test]
fn test_tera_template_rendering() {
    // This test should fail as TemplateEngine doesn't exist yet
    let engine = TemplateEngine::new().unwrap();
    
    let mut context = Context::new();
    context.insert("project_name", "my-project");
    context.insert("author", "Test Author");
    
    let rendered = engine.render("test.tera", &context).unwrap();
    assert!(rendered.contains("my-project"));
    assert!(rendered.contains("Test Author"));
}

#[test]
fn test_variable_substitution() {
    // Test various variable substitution scenarios
    let engine = TemplateEngine::new().unwrap();
    
    let mut context = Context::new();
    context.insert("name", "cargo-forge");
    context.insert("version", "0.1.0");
    context.insert("description", "A Rust project generator");
    context.insert("features", &vec!["async", "serialization", "cli"]);
    
    let rendered = engine.render("test.tera", &context).unwrap();
    
    // Check basic substitutions
    assert!(rendered.contains("cargo-forge"));
    assert!(rendered.contains("0.1.0"));
    assert!(rendered.contains("A Rust project generator"));
    
    // Check array/list rendering
    assert!(rendered.contains("async"));
    assert!(rendered.contains("serialization"));
    assert!(rendered.contains("cli"));
}

#[test]
fn test_template_error_handling() {
    // Test error handling for missing templates
    let engine = TemplateEngine::new().unwrap();
    let context = Context::new();
    
    let result = engine.render("non_existent.tera", &context);
    assert!(result.is_err(), "Should error on missing template");
    
    // Test error handling for missing variables
    let result = engine.render("test.tera", &context);
    // This might succeed with empty values or fail depending on template strictness
    // We'll check that it handles it gracefully either way
    match result {
        Ok(rendered) => assert!(!rendered.is_empty()),
        Err(e) => assert!(e.to_string().contains("variable")),
    }
}

#[test]
fn test_conditional_rendering() {
    // Test Tera conditional statements
    let engine = TemplateEngine::new().unwrap();
    
    let mut context = Context::new();
    context.insert("include_tests", &true);
    context.insert("include_benches", &false);
    context.insert("project_type", "library");
    
    let rendered = engine.render("test.tera", &context).unwrap();
    
    // Assuming the template has conditionals
    assert!(rendered.contains("tests"));
    assert!(!rendered.contains("benches"));
}

#[test]
fn test_template_loops() {
    // Test Tera loop functionality
    let engine = TemplateEngine::new().unwrap();
    
    let mut context = Context::new();
    let dependencies = vec![
        HashMap::from([("name", "tokio"), ("version", "1.0")]),
        HashMap::from([("name", "serde"), ("version", "1.0")]),
        HashMap::from([("name", "clap"), ("version", "4.0")]),
    ];
    context.insert("dependencies", &dependencies);
    
    let rendered = engine.render("test.tera", &context).unwrap();
    
    // Check that all dependencies are rendered
    assert!(rendered.contains("tokio"));
    assert!(rendered.contains("serde"));
    assert!(rendered.contains("clap"));
}

#[test]
fn test_template_filters() {
    // Test Tera filter functionality
    let engine = TemplateEngine::new().unwrap();
    
    let mut context = Context::new();
    context.insert("project_name", "my_project_name");
    context.insert("description", "a very long description that should be truncated");
    
    let rendered = engine.render("test.tera", &context).unwrap();
    
    // Assuming the template uses filters like {{ project_name | replace("_", "-") }}
    // This test will verify filter application works
    assert!(!rendered.contains("my_project_name")); // Should be transformed
}

#[test]
fn test_nested_templates() {
    // Test template inheritance/inclusion
    let engine = TemplateEngine::new().unwrap();
    
    let mut context = Context::new();
    context.insert("project_name", "nested-test");
    
    // Assuming we have a base template that includes others
    let rendered = engine.render("base.tera", &context).unwrap();
    
    // Should include content from included templates
    assert!(rendered.contains("nested-test"));
}

#[test]
fn test_cargo_toml_template() {
    // Specific test for Cargo.toml template rendering
    let engine = TemplateEngine::new().unwrap();
    
    let mut context = Context::new();
    context.insert("project_name", "test-project");
    context.insert("version", "0.1.0");
    context.insert("authors", &vec!["Test Author <test@example.com>"]);
    context.insert("edition", "2021");
    context.insert("description", "A test project");
    
    let rendered = engine.render("sample_cargo.toml.tera", &context).unwrap();
    
    // Verify TOML structure
    assert!(rendered.contains("[package]"));
    assert!(rendered.contains(r#"name = "test-project""#));
    assert!(rendered.contains(r#"version = "0.1.0""#));
    assert!(rendered.contains(r#"edition = "2021""#));
    assert!(rendered.contains("[dependencies]"));
}