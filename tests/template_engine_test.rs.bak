use cargo_forge::templates::{TemplateEngine, conditional::ConditionalRenderer};
use tera::Context;

/// Test TemplateEngine functionality for better coverage
#[cfg(test)]
mod template_engine_tests {
    use super::*;

    #[test]
    fn test_template_engine_creation() {
        let engine = TemplateEngine::new();
        assert!(engine.is_ok());
    }

    #[test]
    fn test_template_engine_with_features() {
        let features = vec!["auth".to_string(), "database".to_string()];
        let engine = TemplateEngine::with_features(features);
        assert!(engine.is_ok());
    }

    #[test]
    fn test_render_existing_template() {
        let engine = TemplateEngine::new().unwrap();
        let mut context = Context::new();
        context.insert("name", "test-project");
        context.insert("author", "Test Author");
        context.insert("description", "Test Description");
        context.insert("rust_version", "1.70");
        context.insert("license", "MIT");
        
        // Test rendering an actual template that exists
        let result = engine.render("library/README.md.tera", &context);
        assert!(result.is_ok());
        
        let rendered = result.unwrap();
        assert!(rendered.contains("test-project"));
        assert!(rendered.contains("Test Author"));
    }

    #[test]
    fn test_render_nonexistent_template() {
        let engine = TemplateEngine::new().unwrap();
        let context = Context::new();
        
        let result = engine.render("nonexistent/template.tera", &context);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not found"));
    }

    #[test]
    fn test_render_with_context_method() {
        let engine = TemplateEngine::new().unwrap();
        let mut context = Context::new();
        context.insert("name", "test-context");
        
        let result = engine.render_with_context("library/README.md.tera", &context);
        assert!(result.is_ok());
        
        let rendered = result.unwrap();
        assert!(rendered.contains("test-context"));
    }

    #[test]
    fn test_template_with_features() {
        let features = vec!["auth".to_string(), "database".to_string()];
        let engine = TemplateEngine::with_features(features).unwrap();
        
        let mut context = Context::new();
        context.insert("name", "test-project");
        context.insert("author", "Test Author");
        context.insert("description", "Test Description");
        context.insert("rust_version", "1.70");
        context.insert("license", "MIT");
        
        let result = engine.render("api_server/README.md.tera", &context);
        assert!(result.is_ok());
        
        let rendered = result.unwrap();
        assert!(rendered.contains("test-project"));
        // Should contain feature-specific content
        assert!(rendered.contains("JWT") || rendered.contains("PostgreSQL") || rendered.contains("auth"));
    }

    #[test]
    fn test_empty_context() {
        let engine = TemplateEngine::new().unwrap();
        let context = Context::new();
        
        // This should fail because required variables are missing
        let result = engine.render("library/README.md.tera", &context);
        // Depending on template implementation, this might succeed with default values
        // or fail with missing variable errors
        let _ = result; // Don't assert either way
    }

    #[test]
    fn test_invalid_template_syntax() {
        let engine = TemplateEngine::new().unwrap();
        let context = Context::new();
        
        // Try to test with a template that has syntax errors
        // Since we can't modify existing templates, we test error handling
        let result = engine.render("invalid-syntax-template.tera", &context);
        assert!(result.is_err());
    }
}

/// Test ConditionalRenderer functionality
#[cfg(test)]
mod conditional_template_engine_tests {
    use super::*;

    #[test]
    fn test_conditional_engine_creation() {
        let features = vec!["auth".to_string(), "database".to_string()];
        let engine = ConditionalRenderer::new(features);
        assert!(engine.is_ok());
    }

    #[test]
    fn test_add_template() {
        let features = vec!["auth".to_string()];
        let mut engine = ConditionalRenderer::new(features).unwrap();
        
        let template_content = "Hello {{ name }}!";
        let result = engine.add_template("test", template_content);
        assert!(result.is_ok());
    }

    #[test]
    fn test_render_conditional_template() {
        let features = vec!["auth".to_string()];
        let mut engine = ConditionalRenderer::new(features).unwrap();
        
        let template_content = "{% if has_feature(feature='auth') %}Auth enabled{% else %}No auth{% endif %}";
        engine.add_template("conditional", template_content).unwrap();
        
        let mut context = Context::new();
        context.insert("name", "test");
        
        let result = engine.render("conditional", &context);
        assert!(result.is_ok());
        
        let rendered = result.unwrap();
        assert!(rendered.contains("Auth enabled"));
    }

    #[test]
    fn test_has_feature_function() {
        let features = vec!["auth".to_string(), "database".to_string()];
        let mut engine = ConditionalRenderer::new(features).unwrap();
        
        let template_content = r#"
        {% if has_feature(feature='auth') %}HAS_AUTH{% endif %}
        {% if has_feature(feature='database') %}HAS_DB{% endif %}
        {% if has_feature(feature='nonexistent') %}HAS_NONEXISTENT{% endif %}
        "#;
        
        engine.add_template("feature_test", template_content).unwrap();
        
        let context = Context::new();
        let result = engine.render("feature_test", &context).unwrap();
        
        assert!(result.contains("HAS_AUTH"));
        assert!(result.contains("HAS_DB"));
        assert!(!result.contains("HAS_NONEXISTENT"));
    }

    #[test]
    fn test_has_any_feature_function() {
        let features = vec!["auth".to_string()];
        let mut engine = ConditionalRenderer::new(features).unwrap();
        
        let template_content = r#"
        {% if has_any_feature(check=['auth', 'database']) %}HAS_ANY{% endif %}
        {% if has_any_feature(check=['nonexistent1', 'nonexistent2']) %}HAS_NONE{% endif %}
        "#;
        
        engine.add_template("any_feature_test", template_content).unwrap();
        
        let context = Context::new();
        let result = engine.render("any_feature_test", &context).unwrap();
        
        assert!(result.contains("HAS_ANY"));
        assert!(!result.contains("HAS_NONE"));
    }

    #[test]
    fn test_has_all_features_function() {
        let features = vec!["auth".to_string(), "database".to_string()];
        let mut engine = ConditionalRenderer::new(features).unwrap();
        
        let template_content = r#"
        {% if has_all_features(check=['auth', 'database']) %}HAS_ALL{% endif %}
        {% if has_all_features(check=['auth', 'nonexistent']) %}HAS_PARTIAL{% endif %}
        "#;
        
        engine.add_template("all_features_test", template_content).unwrap();
        
        let context = Context::new();
        let result = engine.render("all_features_test", &context).unwrap();
        
        assert!(result.contains("HAS_ALL"));
        assert!(!result.contains("HAS_PARTIAL"));
    }

    #[test]
    fn test_invalid_feature_function_calls() {
        let features = vec!["auth".to_string()];
        let mut engine = ConditionalRenderer::new(features).unwrap();
        
        // Test function calls with missing parameters
        let invalid_templates = vec![
            ("missing_param", "{% if has_feature() %}TEST{% endif %}"),
            ("wrong_param", "{% if has_feature(name='auth') %}TEST{% endif %}"),
            ("missing_array", "{% if has_any_feature() %}TEST{% endif %}"),
        ];
        
        for (name, template) in invalid_templates {
            engine.add_template(name, template).unwrap();
            let result = engine.render(name, &Context::new());
            // Should fail with parameter errors
            assert!(result.is_err(), "Template {} should have failed", name);
        }
    }

    #[test]
    fn test_empty_features() {
        let features = vec![];
        let mut engine = ConditionalRenderer::new(features).unwrap();
        
        let template_content = "{% if has_feature(feature='auth') %}HAS_AUTH{% else %}NO_AUTH{% endif %}";
        engine.add_template("empty_features", template_content).unwrap();
        
        let result = engine.render("empty_features", &Context::new()).unwrap();
        assert!(result.contains("NO_AUTH"));
        assert!(!result.contains("HAS_AUTH"));
    }

    #[test]
    fn test_complex_conditional_logic() {
        let features = vec!["auth".to_string(), "database".to_string(), "api".to_string()];
        let mut engine = ConditionalRenderer::new(features).unwrap();
        
        let template_content = r#"
        {% if has_feature(feature='auth') and has_feature(feature='database') %}
        AUTH_AND_DB
        {% endif %}
        {% if has_any_feature(check=['auth', 'api']) and has_feature(feature='database') %}
        COMPLEX_LOGIC
        {% endif %}
        "#;
        
        engine.add_template("complex", template_content).unwrap();
        
        let result = engine.render("complex", &Context::new()).unwrap();
        assert!(result.contains("AUTH_AND_DB"));
        assert!(result.contains("COMPLEX_LOGIC"));
    }
}