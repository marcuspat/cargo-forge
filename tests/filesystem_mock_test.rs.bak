use cargo_forge::{Generator, ProjectConfig, ProjectType};
use std::fs;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tempfile::TempDir;

/// Mock filesystem operations for testing without side effects
#[derive(Debug, Clone)]
pub struct MockFileSystem {
    files: Arc<Mutex<HashMap<String, String>>>,
    directories: Arc<Mutex<HashMap<String, bool>>>, // path -> exists
    read_only_paths: Arc<Mutex<Vec<String>>>,
    permission_denied_paths: Arc<Mutex<Vec<String>>>,
}

impl MockFileSystem {
    pub fn new() -> Self {
        Self {
            files: Arc::new(Mutex::new(HashMap::new())),
            directories: Arc::new(Mutex::new(HashMap::new())),
            read_only_paths: Arc::new(Mutex::new(Vec::new())),
            permission_denied_paths: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub fn add_file(&self, path: &str, content: &str) {
        self.files.lock().unwrap().insert(path.to_string(), content.to_string());
    }

    pub fn add_directory(&self, path: &str) {
        self.directories.lock().unwrap().insert(path.to_string(), true);
    }

    pub fn make_read_only(&self, path: &str) {
        self.read_only_paths.lock().unwrap().push(path.to_string());
    }

    pub fn deny_permission(&self, path: &str) {
        self.permission_denied_paths.lock().unwrap().push(path.to_string());
    }

    pub fn file_exists(&self, path: &str) -> bool {
        self.files.lock().unwrap().contains_key(path)
    }

    pub fn directory_exists(&self, path: &str) -> bool {
        self.directories.lock().unwrap().get(path).unwrap_or(&false).clone()
    }

    pub fn get_file_content(&self, path: &str) -> Option<String> {
        self.files.lock().unwrap().get(path).cloned()
    }

    pub fn is_read_only(&self, path: &str) -> bool {
        self.read_only_paths.lock().unwrap().contains(&path.to_string())
    }

    pub fn is_permission_denied(&self, path: &str) -> bool {
        self.permission_denied_paths.lock().unwrap().contains(&path.to_string())
    }
}

/// Tests using filesystem mocking to avoid side effects
#[cfg(test)]
mod filesystem_mock_tests {
    use super::*;

    #[test]
    fn test_mock_filesystem_basic_operations() {
        let mock_fs = MockFileSystem::new();
        
        // Test file operations
        assert!(!mock_fs.file_exists("test.txt"));
        mock_fs.add_file("test.txt", "content");
        assert!(mock_fs.file_exists("test.txt"));
        assert_eq!(mock_fs.get_file_content("test.txt"), Some("content".to_string()));
        
        // Test directory operations
        assert!(!mock_fs.directory_exists("test_dir"));
        mock_fs.add_directory("test_dir");
        assert!(mock_fs.directory_exists("test_dir"));
        
        // Test permission operations
        assert!(!mock_fs.is_read_only("test.txt"));
        mock_fs.make_read_only("test.txt");
        assert!(mock_fs.is_read_only("test.txt"));
        
        assert!(!mock_fs.is_permission_denied("test_dir"));
        mock_fs.deny_permission("test_dir");
        assert!(mock_fs.is_permission_denied("test_dir"));
    }

    #[test]
    fn test_isolated_project_generation() {
        // Use real filesystem but in isolated temp directories
        let temp_dir = TempDir::new().unwrap();
        let generator = Generator::new();
        
        // Test multiple project generations without interference
        for i in 0..5 {
            let project_dir = temp_dir.path().join(format!("project_{}", i));
            
            let config = ProjectConfig {
                name: format!("test-project-{}", i),
                project_type: ProjectType::Library.to_string(),
                author: format!("Author {}", i),
                description: Some(format!("Test project {}", i)),
            };
            
            let result = generator.generate(&config, &project_dir);
            assert!(result.is_ok(), "Project {} generation failed", i);
            
            // Verify each project is independent
            assert!(project_dir.join("Cargo.toml").exists());
            assert!(project_dir.join("README.md").exists());
            assert!(project_dir.join("src").exists());
            
            let cargo_content = fs::read_to_string(project_dir.join("Cargo.toml")).unwrap();
            assert!(cargo_content.contains(&format!("test-project-{}", i)));
            assert!(cargo_content.contains(&format!("Author {}", i)));
        }
    }

    #[test]
    fn test_concurrent_project_generation() {
        use std::thread;
        use std::sync::Arc;
        
        let temp_dir = Arc::new(TempDir::new().unwrap());
        let generator = Arc::new(Generator::new());
        
        let mut handles = vec![];
        
        // Create multiple projects concurrently
        for i in 0..3 {
            let temp_dir = Arc::clone(&temp_dir);
            let generator = Arc::clone(&generator);
            
            let handle = thread::spawn(move || {
                let project_dir = temp_dir.path().join(format!("concurrent_project_{}", i));
                
                let config = ProjectConfig {
                    name: format!("concurrent-project-{}", i),
                    project_type: ProjectType::Library.to_string(),
                    author: format!("Concurrent Author {}", i),
                    description: Some(format!("Concurrent test project {}", i)),
                };
                
                generator.generate(&config, &project_dir)
            });
            
            handles.push(handle);
        }
        
        // Wait for all threads and check results
        for handle in handles {
            let result = handle.join().unwrap();
            assert!(result.is_ok());
        }
        
        // Verify all projects were created
        for i in 0..3 {
            let project_dir = temp_dir.path().join(format!("concurrent_project_{}", i));
            assert!(project_dir.exists());
            assert!(project_dir.join("Cargo.toml").exists());
        }
    }

    #[test]
    fn test_filesystem_state_isolation() {
        // Each test should start with a clean filesystem state
        let temp_dir1 = TempDir::new().unwrap();
        let temp_dir2 = TempDir::new().unwrap();
        
        let generator = Generator::new();
        
        // Generate project in first temp dir
        let config1 = ProjectConfig {
            name: "isolated-project-1".to_string(),
            project_type: ProjectType::ApiServer.to_string(),
            author: "Author 1".to_string(),
            description: Some("Project 1".to_string()),
        };
        
        let project_dir1 = temp_dir1.path().join("project1");
        generator.generate(&config1, &project_dir1).unwrap();
        
        // Generate different project in second temp dir
        let config2 = ProjectConfig {
            name: "isolated-project-2".to_string(),
            project_type: ProjectType::CliTool.to_string(),
            author: "Author 2".to_string(),
            description: Some("Project 2".to_string()),
        };
        
        let project_dir2 = temp_dir2.path().join("project2");
        generator.generate(&config2, &project_dir2).unwrap();
        
        // Verify projects are completely independent
        let cargo1 = fs::read_to_string(project_dir1.join("Cargo.toml")).unwrap();
        let cargo2 = fs::read_to_string(project_dir2.join("Cargo.toml")).unwrap();
        
        assert!(cargo1.contains("isolated-project-1"));
        assert!(cargo1.contains("Author 1"));
        assert!(!cargo1.contains("isolated-project-2"));
        assert!(!cargo1.contains("Author 2"));
        
        assert!(cargo2.contains("isolated-project-2"));
        assert!(cargo2.contains("Author 2"));
        assert!(!cargo2.contains("isolated-project-1"));
        assert!(!cargo2.contains("Author 1"));
    }

    #[test]
    fn test_cleanup_after_failed_generation() {
        let temp_dir = TempDir::new().unwrap();
        let generator = Generator::new();
        
        // Try to generate in a location that will cause failure
        let invalid_config = ProjectConfig {
            name: "test-project".to_string(),
            project_type: "invalid-type".to_string(), // This will cause failure
            author: "Test Author".to_string(),
            description: Some("Test".to_string()),
        };
        
        let project_dir = temp_dir.path().join("failed_project");
        let result = generator.generate(&invalid_config, &project_dir);
        
        assert!(result.is_err());
        
        // Verify no partial files were left behind
        // (This depends on the generator implementation)
        if project_dir.exists() {
            let entries = fs::read_dir(&project_dir).unwrap();
            let count = entries.count();
            // Should be empty or not exist
            assert!(count == 0 || !project_dir.exists());
        }
    }

    #[test]
    fn test_memory_usage_during_generation() {
        // Test that generation doesn't consume excessive memory
        let temp_dir = TempDir::new().unwrap();
        let generator = Generator::new();
        
        // Generate multiple large projects
        for i in 0..10 {
            let config = ProjectConfig {
                name: format!("memory-test-{}", i),
                project_type: ProjectType::Workspace.to_string(), // Largest project type
                author: "Memory Test Author".to_string(),
                description: Some("Testing memory usage during generation".to_string()),
            };
            
            let project_dir = temp_dir.path().join(format!("memory_test_{}", i));
            let result = generator.generate(&config, &project_dir);
            assert!(result.is_ok(), "Memory test project {} failed", i);
            
            // Simple memory pressure test - if we got here without OOM, we're probably fine
            assert!(project_dir.exists());
        }
    }

    #[test]
    fn test_temporary_file_handling() {
        let temp_dir = TempDir::new().unwrap();
        let generator = Generator::new();
        
        // Create some temporary files that might interfere
        let temp_file = temp_dir.path().join(".tmp_file");
        fs::write(&temp_file, "temporary content").unwrap();
        
        let config = ProjectConfig {
            name: "temp-test".to_string(),
            project_type: ProjectType::Library.to_string(),
            author: "Temp Test Author".to_string(),
            description: Some("Testing with temporary files present".to_string()),
        };
        
        let project_dir = temp_dir.path().join("temp_test_project");
        let result = generator.generate(&config, &project_dir);
        assert!(result.is_ok());
        
        // Verify temporary file still exists (shouldn't be affected)
        assert!(temp_file.exists());
        
        // Verify project was created correctly
        assert!(project_dir.join("Cargo.toml").exists());
    }

    #[test]
    fn test_unicode_filesystem_paths() {
        let temp_dir = TempDir::new().unwrap();
        let generator = Generator::new();
        
        // Test with unicode directory names
        let unicode_paths = vec![
            "测试项目",
            "тест",
            "テスト",
            "🚀project",
        ];
        
        for (i, unicode_name) in unicode_paths.iter().enumerate() {
            let config = ProjectConfig {
                name: format!("unicode-test-{}", i),
                project_type: ProjectType::Library.to_string(),
                author: "Unicode Test Author".to_string(),
                description: Some("Testing unicode paths".to_string()),
            };
            
            let project_dir = temp_dir.path().join(unicode_name);
            let result = generator.generate(&config, &project_dir);
            
            // May succeed or fail depending on filesystem support
            // We don't assert either way, just test the code path
            let _ = result;
        }
    }
}