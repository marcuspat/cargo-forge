use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};
use zeroize::Zeroize;

pub struct PasswordManager {
    argon2: Argon2<'static>,
}

impl PasswordManager {
    pub fn new() -> Self {
        // Configure Argon2 with secure defaults
        let argon2 = Argon2::default();
        Self { argon2 }
    }
    
    pub fn with_config(memory_cost: u32, time_cost: u32, parallelism: u32) -> Self {
        use argon2::{Algorithm, Params, Version};
        
        let params = Params::new(memory_cost, time_cost, parallelism, None)
            .expect("Invalid Argon2 parameters");
        
        let argon2 = Argon2::new(Algorithm::Argon2id, Version::V0x13, params);
        Self { argon2 }
    }
    
    /// Hash a password with a random salt
    pub fn hash_password(&self, password: &str) -> Result<String, argon2::password_hash::Error> {
        let salt = SaltString::generate(&mut OsRng);
        let password_hash = self.argon2.hash_password(password.as_bytes(), &salt)?;
        Ok(password_hash.to_string())
    }
    
    /// Verify a password against a hash
    pub fn verify_password(&self, password: &str, hash: &str) -> Result<bool, argon2::password_hash::Error> {
        let parsed_hash = PasswordHash::new(hash)?;
        match self.argon2.verify_password(password.as_bytes(), &parsed_hash) {
            Ok(_) => Ok(true),
            Err(argon2::password_hash::Error::Password) => Ok(false),
            Err(e) => Err(e),
        }
    }
    
    /// Check if a password hash needs to be updated (rehashed with new parameters)
    pub fn needs_rehash(&self, hash: &str) -> bool {
        match PasswordHash::new(hash) {
            Ok(parsed_hash) => {
                // Check if the hash was created with current parameters
                // This is a simplified check - in production you might want more sophisticated logic
                parsed_hash.algorithm != argon2::Algorithm::Argon2id
            }
            Err(_) => true, // If we can't parse it, it definitely needs rehashing
        }
    }
}

impl Default for PasswordManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Password strength validator
pub struct PasswordValidator {
    min_length: usize,
    require_uppercase: bool,
    require_lowercase: bool,
    require_numbers: bool,
    require_special: bool,
}

impl PasswordValidator {
    pub fn new() -> Self {
        Self {
            min_length: 8,
            require_uppercase: true,
            require_lowercase: true,
            require_numbers: true,
            require_special: true,
        }
    }
    
    pub fn min_length(mut self, length: usize) -> Self {
        self.min_length = length;
        self
    }
    
    pub fn validate(&self, password: &str) -> Result<(), Vec<String>> {
        let mut errors = Vec::new();
        
        if password.len() < self.min_length {
            errors.push(format!("Password must be at least {} characters long", self.min_length));
        }
        
        if self.require_uppercase && !password.chars().any(|c| c.is_uppercase()) {
            errors.push("Password must contain at least one uppercase letter".to_string());
        }
        
        if self.require_lowercase && !password.chars().any(|c| c.is_lowercase()) {
            errors.push("Password must contain at least one lowercase letter".to_string());
        }
        
        if self.require_numbers && !password.chars().any(|c| c.is_numeric()) {
            errors.push("Password must contain at least one number".to_string());
        }
        
        if self.require_special && !password.chars().any(|c| !c.is_alphanumeric()) {
            errors.push("Password must contain at least one special character".to_string());
        }
        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(errors)
        }
    }
}

impl Default for PasswordValidator {
    fn default() -> Self {
        Self::new()
    }
}

/// Secure password generation
pub fn generate_password(length: usize) -> String {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                            abcdefghijklmnopqrstuvwxyz\
                            0123456789\
                            !@#$%^&*()_+-=[]{}|;:,.<>?";
    let mut rng = rand::thread_rng();
    
    let password: String = (0..length)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect();
    
    password
}

/// Secure string that zeros memory on drop
pub struct SecureString(String);

impl SecureString {
    pub fn new(s: String) -> Self {
        Self(s)
    }
    
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl Drop for SecureString {
    fn drop(&mut self) {
        self.0.zeroize();
    }
}

impl From<String> for SecureString {
    fn from(s: String) -> Self {
        Self::new(s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_password_hashing_and_verification() {
        let password_manager = PasswordManager::new();
        let password = "secure_password123!";
        
        let hash = password_manager.hash_password(password).unwrap();
        assert!(!hash.is_empty());
        assert!(hash.starts_with("$argon2"));
        
        // Verify correct password
        assert!(password_manager.verify_password(password, &hash).unwrap());
        
        // Verify incorrect password
        assert!(!password_manager.verify_password("wrong_password", &hash).unwrap());
    }
    
    #[test]
    fn test_different_hashes_for_same_password() {
        let password_manager = PasswordManager::new();
        let password = "test_password";
        
        let hash1 = password_manager.hash_password(password).unwrap();
        let hash2 = password_manager.hash_password(password).unwrap();
        
        // Hashes should be different due to random salts
        assert_ne!(hash1, hash2);
        
        // But both should verify correctly
        assert!(password_manager.verify_password(password, &hash1).unwrap());
        assert!(password_manager.verify_password(password, &hash2).unwrap());
    }
    
    #[test]
    fn test_password_validator() {
        let validator = PasswordValidator::new();
        
        // Valid password
        assert!(validator.validate("SecureP@ss123").is_ok());
        
        // Too short
        assert!(validator.validate("Short1!").is_err());
        
        // Missing uppercase
        assert!(validator.validate("lowercase@123").is_err());
        
        // Missing lowercase
        assert!(validator.validate("UPPERCASE@123").is_err());
        
        // Missing numbers
        assert!(validator.validate("NoNumbers!@#").is_err());
        
        // Missing special characters
        assert!(validator.validate("NoSpecial123").is_err());
    }
    
    #[test]
    fn test_password_generation() {
        let password = generate_password(16);
        
        assert_eq!(password.len(), 16);
        
        // Should pass validation
        let validator = PasswordValidator::new();
        // Generated passwords are random, so we can't guarantee they pass all requirements
        // But they should at least have the correct length
        assert!(password.len() >= 8);
    }
    
    #[test]
    fn test_secure_string() {
        let secure = SecureString::new("sensitive_data".to_string());
        assert_eq!(secure.as_str(), "sensitive_data");
        
        // When secure goes out of scope, the string data will be zeroed
    }
}