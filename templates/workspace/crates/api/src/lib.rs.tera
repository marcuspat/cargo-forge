//! API server for {{ project_name }}
//!
//! This crate provides the HTTP API endpoints and server functionality.

{% if "web" in features %}
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tower_http::{cors::CorsLayer, trace::TraceLayer};
use tracing::{info, instrument};
use uuid::Uuid;

use {{ project_name | replace(from="-", to="_") }}_core::{models::*, CoreError, Result};

pub mod handlers;
pub mod middleware;
pub mod routes;
pub mod state;

pub use state::AppState;

/// API response wrapper
#[derive(Debug, Serialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
}

impl<T> ApiResponse<T> {
    pub fn success(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
        }
    }

    pub fn error(message: String) -> ApiResponse<()> {
        ApiResponse {
            success: false,
            data: None,
            error: Some(message),
        }
    }
}

/// Create the API router
pub fn create_router(state: AppState) -> Router {
    Router::new()
        .route("/health", get(health_check))
        .route("/users", get(list_users).post(create_user))
        .route("/users/:id", get(get_user))
        .layer(CorsLayer::permissive())
        .layer(TraceLayer::new_for_http())
        .with_state(state)
}

/// Health check endpoint
#[instrument]
async fn health_check() -> Json<ApiResponse<&'static str>> {
    info!("Health check requested");
    Json(ApiResponse::success("OK"))
}

/// List users endpoint
#[instrument(skip(state))]
async fn list_users(
    Query(params): Query<ListUsersQuery>,
    State(state): State<AppState>,
) -> Result<Json<ApiResponse<PaginatedResponse<User>>>, ApiError> {
    let pagination = Pagination::new(params.page.unwrap_or(1), params.per_page.unwrap_or(10), 0);
    
    // Mock users for now
    let users = vec![
        User::new("john_doe".to_string(), "john@example.com".to_string()),
        User::new("jane_smith".to_string(), "jane@example.com".to_string()),
    ];
    
    let response = PaginatedResponse::new(users, pagination);
    Ok(Json(ApiResponse::success(response)))
}

/// Create user endpoint
#[instrument(skip(state))]
async fn create_user(
    State(state): State<AppState>,
    Json(request): Json<CreateUserRequest>,
) -> Result<Json<ApiResponse<User>>, ApiError> {
    let user = User::new(request.username, request.email)
        .with_display_name(request.display_name.unwrap_or_default());
    
    Ok(Json(ApiResponse::success(user)))
}

/// Get user by ID endpoint
#[instrument(skip(state))]
async fn get_user(
    Path(id): Path<Uuid>,
    State(state): State<AppState>,
) -> Result<Json<ApiResponse<User>>, ApiError> {
    // Mock user lookup
    let user = User::new("john_doe".to_string(), "john@example.com".to_string());
    Ok(Json(ApiResponse::success(user)))
}

/// Query parameters for listing users
#[derive(Debug, Deserialize)]
struct ListUsersQuery {
    page: Option<u32>,
    per_page: Option<u32>,
}

/// Request body for creating a user
#[derive(Debug, Deserialize)]
struct CreateUserRequest {
    username: String,
    email: String,
    display_name: Option<String>,
}

/// API error type
#[derive(Debug)]
pub struct ApiError(CoreError);

impl From<CoreError> for ApiError {
    fn from(err: CoreError) -> Self {
        Self(err)
    }
}

impl axum::response::IntoResponse for ApiError {
    fn into_response(self) -> axum::response::Response {
        let (status, error_message) = match &self.0 {
            CoreError::Validation { .. } => (StatusCode::BAD_REQUEST, self.0.to_string()),
            CoreError::NotFound { .. } => (StatusCode::NOT_FOUND, self.0.to_string()),
            CoreError::AlreadyExists { .. } => (StatusCode::CONFLICT, self.0.to_string()),
            CoreError::PermissionDenied { .. } => (StatusCode::FORBIDDEN, self.0.to_string()),
            _ => (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error".to_string()),
        };

        let body = Json(ApiResponse::<()>::error(error_message));
        (status, body).into_response()
    }
}

/// Start the API server
pub async fn serve(state: AppState, port: u16) -> Result<()> {
    let app = create_router(state);
    let addr = format!("0.0.0.0:{}", port);
    
    info!("Starting server on {}", addr);
    
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum::http::Request;
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_health_check() {
        let state = AppState::new();
        let app = create_router(state);

        let response = app
            .oneshot(Request::builder().uri("/health").body(axum::body::Body::empty()).unwrap())
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);
    }
}
{% else %}
//! API library for {{ project_name }}
//!
//! This crate provides the core API functionality.
//! Enable the "web" feature to get HTTP server capabilities.

pub use {{ project_name | replace(from="-", to="_") }}_core::*;

/// API client or service logic would go here
pub struct ApiClient {
    base_url: String,
}

impl ApiClient {
    pub fn new(base_url: String) -> Self {
        Self { base_url }
    }
}
{% endif %}